/**
 * SQL Schema builder for creating WhatsApp message storage tables
 * This provides the SQL needed to create tables in various databases
 */

export interface SchemaOptions {
  messagesTable?: string;
  conversationsTable?: string;
  enableRLS?: boolean;
  tablePrefix?: string;
}

export class SchemaBuilder {
  private options: Required<SchemaOptions>;

  constructor(options: SchemaOptions = {}) {
    this.options = {
      messagesTable: options.messagesTable || 'whatsapp_messages',
      conversationsTable: options.conversationsTable || 'whatsapp_conversations',
      enableRLS: options.enableRLS || false,
      tablePrefix: options.tablePrefix || 'whatsapp_'
    };
  }

  /**
   * Generate PostgreSQL/Supabase schema
   */
  generateSupabaseSchema(): string {
    const { messagesTable, conversationsTable, enableRLS } = this.options;

    return `
-- WhatsApp SDK Storage Tables
-- Generated by WhatsApp SDK SchemaBuilder

-- Create conversations table
CREATE TABLE IF NOT EXISTS ${conversationsTable} (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  phone_number VARCHAR(20) NOT NULL,
  business_phone_id VARCHAR(20) NOT NULL,
  last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  message_count INTEGER DEFAULT 0,
  unread_count INTEGER DEFAULT 0,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Indexes
  UNIQUE(phone_number, business_phone_id)
);

-- Create messages table
CREATE TABLE IF NOT EXISTS ${messagesTable} (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  whatsapp_message_id VARCHAR(255) UNIQUE NOT NULL,
  conversation_id UUID REFERENCES ${conversationsTable}(id) ON DELETE CASCADE,
  phone_number_id VARCHAR(20) NOT NULL,
  from_phone VARCHAR(20) NOT NULL,
  to_phone VARCHAR(20) NOT NULL,
  message_type VARCHAR(20) NOT NULL,
  content JSONB NOT NULL DEFAULT '{}',
  reply_to_message_id UUID REFERENCES ${messagesTable}(id) ON DELETE SET NULL,
  whatsapp_reply_to_id VARCHAR(255),
  timestamp TIMESTAMPTZ NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'sent',
  direction VARCHAR(10) NOT NULL CHECK (direction IN ('incoming', 'outgoing')),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_conversation ON ${messagesTable}(conversation_id);
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_from_phone ON ${messagesTable}(from_phone);
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_to_phone ON ${messagesTable}(to_phone);
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_timestamp ON ${messagesTable}(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_type ON ${messagesTable}(message_type);
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_direction ON ${messagesTable}(direction);
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_status ON ${messagesTable}(status);
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_reply ON ${messagesTable}(reply_to_message_id);
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_whatsapp_reply ON ${messagesTable}(whatsapp_reply_to_id);

-- Full-text search index for content
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_content_search ON ${messagesTable}
  USING GIN ((content->>'text'));

-- Composite indexes for common queries
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_phone_timestamp ON ${messagesTable}(from_phone, timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_${messagesTable}_conversation_timestamp ON ${messagesTable}(conversation_id, timestamp DESC);

-- Conversations indexes
CREATE INDEX IF NOT EXISTS idx_${conversationsTable}_phone ON ${conversationsTable}(phone_number);
CREATE INDEX IF NOT EXISTS idx_${conversationsTable}_business ON ${conversationsTable}(business_phone_id);
CREATE INDEX IF NOT EXISTS idx_${conversationsTable}_last_message ON ${conversationsTable}(last_message_at DESC);

-- Functions for maintaining conversation metadata
CREATE OR REPLACE FUNCTION update_conversation_on_message()
RETURNS TRIGGER AS $$
BEGIN
  -- Update conversation activity and message count
  UPDATE ${conversationsTable}
  SET
    last_message_at = NEW.timestamp,
    message_count = message_count + 1,
    updated_at = NOW()
  WHERE id = NEW.conversation_id;

  -- If this is an incoming message, increment unread count
  IF NEW.direction = 'incoming' THEN
    UPDATE ${conversationsTable}
    SET unread_count = unread_count + 1
    WHERE id = NEW.conversation_id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically update conversation metadata
DROP TRIGGER IF EXISTS update_conversation_trigger ON ${messagesTable};
CREATE TRIGGER update_conversation_trigger
  AFTER INSERT ON ${messagesTable}
  FOR EACH ROW
  EXECUTE FUNCTION update_conversation_on_message();

-- Function for marking messages as read
CREATE OR REPLACE FUNCTION mark_messages_read(conversation_uuid UUID)
RETURNS void AS $$
BEGIN
  UPDATE ${conversationsTable}
  SET unread_count = 0, updated_at = NOW()
  WHERE id = conversation_uuid;
END;
$$ LANGUAGE plpgsql;

-- Function for cleaning up old messages
CREATE OR REPLACE FUNCTION cleanup_old_messages(retention_days INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM ${messagesTable}
  WHERE created_at < NOW() - (retention_days || ' days')::INTERVAL;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Function for getting conversation stats
CREATE OR REPLACE FUNCTION get_conversation_stats(phone_number_param VARCHAR)
RETURNS TABLE(
  total_messages BIGINT,
  incoming_messages BIGINT,
  outgoing_messages BIGINT,
  first_message_at TIMESTAMPTZ,
  last_message_at TIMESTAMPTZ,
  avg_response_time_minutes NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*) as total_messages,
    COUNT(*) FILTER (WHERE direction = 'incoming') as incoming_messages,
    COUNT(*) FILTER (WHERE direction = 'outgoing') as outgoing_messages,
    MIN(timestamp) as first_message_at,
    MAX(timestamp) as last_message_at,
    AVG(EXTRACT(EPOCH FROM (
      LEAD(timestamp) OVER (ORDER BY timestamp) - timestamp
    )) / 60) as avg_response_time_minutes
  FROM ${messagesTable} m
  JOIN ${conversationsTable} c ON m.conversation_id = c.id
  WHERE c.phone_number = phone_number_param;
END;
$$ LANGUAGE plpgsql;

${enableRLS ? this.generateRLSPolicies(messagesTable, conversationsTable) : ''}

-- Views for common queries
CREATE OR REPLACE VIEW ${messagesTable}_with_replies AS
SELECT
  m.*,
  rm.id as reply_id,
  rm.content as reply_content,
  rm.timestamp as reply_timestamp
FROM ${messagesTable} m
LEFT JOIN ${messagesTable} rm ON rm.reply_to_message_id = m.id
ORDER BY m.timestamp DESC, rm.timestamp ASC;

CREATE OR REPLACE VIEW conversation_summary AS
SELECT
  c.*,
  m.content->>'text' as last_message_text,
  m.message_type as last_message_type,
  m.direction as last_message_direction,
  m.timestamp as last_message_timestamp
FROM ${conversationsTable} c
LEFT JOIN ${messagesTable} m ON m.conversation_id = c.id
  AND m.timestamp = c.last_message_at
ORDER BY c.last_message_at DESC;

-- Grant permissions (adjust as needed)
-- GRANT SELECT, INSERT, UPDATE, DELETE ON ${messagesTable} TO authenticated;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON ${conversationsTable} TO authenticated;
-- GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO authenticated;
`;
  }

  private generateRLSPolicies(messagesTable: string, conversationsTable: string): string {
    return `

-- Enable Row Level Security
ALTER TABLE ${messagesTable} ENABLE ROW LEVEL SECURITY;
ALTER TABLE ${conversationsTable} ENABLE ROW LEVEL SECURITY;

-- RLS Policies for messages table
CREATE POLICY "Users can view their own messages" ON ${messagesTable}
  FOR SELECT USING (
    auth.uid()::text = metadata->>'user_id' OR
    auth.uid()::text = metadata->>'business_owner_id'
  );

CREATE POLICY "Users can insert their own messages" ON ${messagesTable}
  FOR INSERT WITH CHECK (
    auth.uid()::text = metadata->>'user_id' OR
    auth.uid()::text = metadata->>'business_owner_id'
  );

CREATE POLICY "Users can update their own messages" ON ${messagesTable}
  FOR UPDATE USING (
    auth.uid()::text = metadata->>'user_id' OR
    auth.uid()::text = metadata->>'business_owner_id'
  );

-- RLS Policies for conversations table
CREATE POLICY "Users can view their own conversations" ON ${conversationsTable}
  FOR SELECT USING (
    auth.uid()::text = metadata->>'user_id' OR
    auth.uid()::text = metadata->>'business_owner_id'
  );

CREATE POLICY "Users can insert their own conversations" ON ${conversationsTable}
  FOR INSERT WITH CHECK (
    auth.uid()::text = metadata->>'user_id' OR
    auth.uid()::text = metadata->>'business_owner_id'
  );

CREATE POLICY "Users can update their own conversations" ON ${conversationsTable}
  FOR UPDATE USING (
    auth.uid()::text = metadata->>'user_id' OR
    auth.uid()::text = metadata->>'business_owner_id'
  );
`;
  }

  /**
   * Generate MySQL schema
   */
  generateMySQLSchema(): string {
    const { messagesTable, conversationsTable } = this.options;

    return `
-- WhatsApp SDK Storage Tables - MySQL
-- Generated by WhatsApp SDK SchemaBuilder

-- Create conversations table
CREATE TABLE IF NOT EXISTS \`${conversationsTable}\` (
  \`id\` CHAR(36) PRIMARY KEY DEFAULT (UUID()),
  \`phone_number\` VARCHAR(20) NOT NULL,
  \`business_phone_id\` VARCHAR(20) NOT NULL,
  \`last_message_at\` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  \`message_count\` INT DEFAULT 0,
  \`unread_count\` INT DEFAULT 0,
  \`metadata\` JSON,
  \`created_at\` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  \`updated_at\` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY \`uk_phone_business\` (\`phone_number\`, \`business_phone_id\`),
  KEY \`idx_phone_number\` (\`phone_number\`),
  KEY \`idx_last_message\` (\`last_message_at\` DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- Create messages table
CREATE TABLE IF NOT EXISTS \`${messagesTable}\` (
  \`id\` CHAR(36) PRIMARY KEY DEFAULT (UUID()),
  \`whatsapp_message_id\` VARCHAR(255) UNIQUE NOT NULL,
  \`conversation_id\` CHAR(36),
  \`phone_number_id\` VARCHAR(20) NOT NULL,
  \`from_phone\` VARCHAR(20) NOT NULL,
  \`to_phone\` VARCHAR(20) NOT NULL,
  \`message_type\` VARCHAR(20) NOT NULL,
  \`content\` JSON NOT NULL,
  \`reply_to_message_id\` CHAR(36),
  \`whatsapp_reply_to_id\` VARCHAR(255),
  \`timestamp\` TIMESTAMP NOT NULL,
  \`status\` VARCHAR(20) NOT NULL DEFAULT 'sent',
  \`direction\` ENUM('incoming', 'outgoing') NOT NULL,
  \`metadata\` JSON,
  \`created_at\` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  \`updated_at\` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  KEY \`idx_conversation\` (\`conversation_id\`),
  KEY \`idx_from_phone\` (\`from_phone\`),
  KEY \`idx_timestamp\` (\`timestamp\` DESC),
  KEY \`idx_type\` (\`message_type\`),
  KEY \`idx_direction\` (\`direction\`),
  KEY \`idx_status\` (\`status\`),
  KEY \`idx_reply\` (\`reply_to_message_id\`),
  KEY \`idx_phone_timestamp\` (\`from_phone\`, \`timestamp\` DESC),

  FOREIGN KEY (\`conversation_id\`) REFERENCES \`${conversationsTable}\`(\`id\`) ON DELETE CASCADE,
  FOREIGN KEY (\`reply_to_message_id\`) REFERENCES \`${messagesTable}\`(\`id\`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
`;
  }

  /**
   * Generate SQLite schema
   */
  generateSQLiteSchema(): string {
    const { messagesTable, conversationsTable } = this.options;

    return `
-- WhatsApp SDK Storage Tables - SQLite
-- Generated by WhatsApp SDK SchemaBuilder

-- Create conversations table
CREATE TABLE IF NOT EXISTS "${conversationsTable}" (
  "id" TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  "phone_number" TEXT NOT NULL,
  "business_phone_id" TEXT NOT NULL,
  "last_message_at" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "message_count" INTEGER DEFAULT 0,
  "unread_count" INTEGER DEFAULT 0,
  "metadata" TEXT DEFAULT '{}',
  "created_at" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  UNIQUE("phone_number", "business_phone_id")
);

-- Create messages table
CREATE TABLE IF NOT EXISTS "${messagesTable}" (
  "id" TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  "whatsapp_message_id" TEXT UNIQUE NOT NULL,
  "conversation_id" TEXT,
  "phone_number_id" TEXT NOT NULL,
  "from_phone" TEXT NOT NULL,
  "to_phone" TEXT NOT NULL,
  "message_type" TEXT NOT NULL,
  "content" TEXT NOT NULL DEFAULT '{}',
  "reply_to_message_id" TEXT,
  "whatsapp_reply_to_id" TEXT,
  "timestamp" DATETIME NOT NULL,
  "status" TEXT NOT NULL DEFAULT 'sent',
  "direction" TEXT NOT NULL CHECK ("direction" IN ('incoming', 'outgoing')),
  "metadata" TEXT DEFAULT '{}',
  "created_at" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY ("conversation_id") REFERENCES "${conversationsTable}"("id") ON DELETE CASCADE,
  FOREIGN KEY ("reply_to_message_id") REFERENCES "${messagesTable}"("id") ON DELETE SET NULL
);

-- Create indexes
CREATE INDEX IF NOT EXISTS "idx_${messagesTable}_conversation" ON "${messagesTable}"("conversation_id");
CREATE INDEX IF NOT EXISTS "idx_${messagesTable}_from_phone" ON "${messagesTable}"("from_phone");
CREATE INDEX IF NOT EXISTS "idx_${messagesTable}_timestamp" ON "${messagesTable}"("timestamp" DESC);
CREATE INDEX IF NOT EXISTS "idx_${messagesTable}_type" ON "${messagesTable}"("message_type");
CREATE INDEX IF NOT EXISTS "idx_${messagesTable}_direction" ON "${messagesTable}"("direction");
CREATE INDEX IF NOT EXISTS "idx_${messagesTable}_status" ON "${messagesTable}"("status");

CREATE INDEX IF NOT EXISTS "idx_${conversationsTable}_phone" ON "${conversationsTable}"("phone_number");
CREATE INDEX IF NOT EXISTS "idx_${conversationsTable}_last_message" ON "${conversationsTable}"("last_message_at" DESC);
`;
  }

  /**
   * Generate schema for a specific database type
   */
  generateSchema(dbType: 'postgresql' | 'mysql' | 'sqlite' = 'postgresql'): string {
    switch (dbType) {
      case 'postgresql':
        return this.generateSupabaseSchema();
      case 'mysql':
        return this.generateMySQLSchema();
      case 'sqlite':
        return this.generateSQLiteSchema();
      default:
        return this.generateSupabaseSchema();
    }
  }

  /**
   * Get the SQL for creating a specific table
   */
  getTableCreationSQL(tableName: 'messages' | 'conversations', dbType: 'postgresql' | 'mysql' | 'sqlite' = 'postgresql'): string {
    const fullSchema = this.generateSchema(dbType);
    const lines = fullSchema.split('\n');

    const targetTable = tableName === 'messages' ? this.options.messagesTable : this.options.conversationsTable;
    const startPattern = new RegExp(`CREATE TABLE.*${targetTable}`, 'i');

    let startIdx = -1;
    let endIdx = -1;

    for (let i = 0; i < lines.length; i++) {
      if (startIdx === -1 && startPattern.test(lines[i])) {
        startIdx = i;
      } else if (startIdx !== -1 && lines[i].trim() === ');') {
        endIdx = i;
        break;
      }
    }

    if (startIdx !== -1 && endIdx !== -1) {
      return lines.slice(startIdx, endIdx + 1).join('\n');
    }

    return '';
  }
}